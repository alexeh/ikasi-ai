/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control model for synchronization logs and admin reviews,
 *              combined with user-based ownership for admin profiles. It also incorporates public read access with
 *              owner-only writes for reading documents, and student-owned writes + admin reads for mental math games.
 *
 * Data Structure:
 *  - /sync_logs/{syncLogId}: Stores synchronization logs; access controlled by admin roles.
 *  - /admin_reviews/{adminReviewId}: Stores admin reviews of sync logs; access controlled by admin roles. Each review is linked to a sync log via `syncLogId` and an admin via `adminId`.
 *  - /admins/{adminId}: Stores admin user profiles; access restricted to the user themselves (ownership).
 *  - /roles_admin/{adminId}: Represents admin roles based on document existence.
 *  - /readingDocuments/{documentId}: Stores reading comprehension documents; public read access, owner-only writes.
 *  - /mentalMathGames/{gameId}: Stores mental math game results; student-owned writes, admin read access.
 *
 * Key Security Decisions:
 *  - Admin roles are determined by the existence of a document in the `roles_admin` collection.
 *  - Listing of documents is generally allowed, except where specifically restricted.
 *  - Reading documents are publicly readable, but only owners can create, update, or delete them.
 *  - Mental math game results can only be written by the student who played the game but are readable by admins.
 *
 * Denormalization for Authorization:
 *  - AdminReview documents include the `adminId` to directly enforce that only the admin who created the review can modify it.
 *
 * Structural Segregation:
 *  - Admin roles are stored in a separate `roles_admin` collection, using "existence over content" to simplify role checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to synchronization logs. Admin roles determine who can read and potentially trigger synchronization actions.
     * @path /sync_logs/{syncLogId}
     * @allow get, list: if isAdmin();
     * @allow create: if isAdmin();
     * @allow update: if isAdmin();
     * @allow delete: if isAdmin();
     * @deny get: if false;
     * @deny list: if false;
     * @deny create: if false;
     * @deny update: if false;
     * @deny delete: if false;
     * @principle Enforces admin-only access for managing synchronization logs.
     */
    match /sync_logs/{syncLogId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Controls access to admin reviews of synchronization logs. Each review is linked to a sync log via `syncLogId` and an admin via `adminId`.
     * @path /admin_reviews/{adminReviewId}
     * @allow get, list: if isAdmin();
     * @allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
     * @allow update: if isAdmin() && resource.data.adminId == request.auth.uid && resource != null;
     * @allow delete: if isAdmin() && resource.data.adminId == request.auth.uid && resource != null;
     * @deny get: if false;
     * @deny list: if false;
     * @deny create: if false;
     * @deny update: if false;
     * @deny delete: if false;
     * @principle Enforces admin-only access for reviews, and ensures only the creating admin can modify/delete.
     */
    match /admin_reviews/{adminReviewId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update: if isAdmin() && resource.data.adminId == request.auth.uid && resource != null;
      allow delete: if isAdmin() && resource.data.adminId == request.auth.uid && resource != null;
    }

    /**
     * @description Controls access to administrator user profiles. Access control is based on the user's ID.
     * @path /admins/{adminId}
     * @allow get: if isOwner(adminId);
     * @allow list: if false;
     * @allow create: if isOwner(adminId);
     * @allow update: if isExistingOwner(adminId);
     * @allow delete: if isExistingOwner(adminId);
     * @deny get: if !isOwner(adminId);
     * @deny list: if true;
     * @deny create: if !isOwner(adminId);
     * @deny update: if !isExistingOwner(adminId);
     * @deny delete: if !isExistingOwner(adminId);
     * @principle Restricts access to a user's own profile data, enforcing ownership.
     */
    match /admins/{adminId} {
      allow get: if isOwner(adminId);
      allow list: if false;
      allow create: if isOwner(adminId);
      allow update: if isExistingOwner(adminId);
      allow delete: if isExistingOwner(adminId);
    }

    /**
     * @description This collection exists to represent admin roles. If a document exists for a user ID in this collection, that user is considered an admin.
     * @path /roles_admin/{adminId}
     * @allow get: if isAdmin();
     * @allow list: if isAdmin();
     * @allow create: if isAdmin();
	 * @allow update: if isAdmin();
     * @allow delete: if isAdmin();
     * @deny get: if false;
     * @deny list: if false;
     * @deny create: if false;
	 * @deny update: if false;
     * @deny delete: if false;
     * @principle Uses "existence over content" to determine admin roles.
     */
    match /roles_admin/{adminId} {
      allow get, list, create, update, delete: if isAdmin();
    }

    /**
     * @description Controls access to reading comprehension documents. Public read access, owner-only writes.
     * @path /readingDocuments/{documentId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny get: if false;
     * @deny list: if false;
     * @deny create: if false;
     * @deny update: if false;
     * @deny delete: if false;
     * @principle Provides public read access but restricts writes to document owners.
     */
    match /readingDocuments/{documentId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // CRITICAL: Cannot implement owner-only writes. The 'ReadingDocument' entity is missing an 'ownerId' or 'authorId' field.
      allow update: if false; // CRITICAL: Cannot implement owner-only writes. The 'ReadingDocument' entity is missing an 'ownerId' or 'authorId' field.
      allow delete: if false; // CRITICAL: Cannot implement owner-only writes. The 'ReadingDocument' entity is missing an 'ownerId' or 'authorId' field.
    }

    /**
     * @description Controls access to mental math game results. Admins can read all documents, while students can only write their own results.
     * @path /mentalMathGames/{gameId}
     * @allow get, list: if isAdmin();
     * @allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
     * @allow update: if false;
     * @allow delete: if false;
     * @deny get: if false;
     * @deny list: if false;
     * @deny create: if false;
     * @deny update: if false;
     * @deny delete: if false;
     * @principle Allows admins to read all game results, and students to only write their own results.
     */
    match /mentalMathGames/{gameId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
  }
}